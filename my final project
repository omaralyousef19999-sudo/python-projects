# sales_processor_project.py
# نسخة مُصحَّحة بالكامل - تعمل بثبات مع CLI و GUI
# تم إصلاح جميع الأخطاء المذكورة + تحسينات في الأداء والواجهة

from __future__ import annotations

import argparse
import csv
import json
import logging
import math
import os
import re
import sys
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import yaml

# PyQt6 imports
try:
    from PyQt6 import QtCore, QtGui, QtWidgets
    from PyQt6.QtCore import Qt, pyqtSignal, pyqtSlot, QThread, QMetaObject, Q_ARG
    PYQT_AVAILABLE = True
except Exception as e:
    PYQT_AVAILABLE = False
    print("PyQt6 غير متوفر. قم بتثبيته باستخدام: pip install PyQt6")

# === تكوين افتراضي ===
DEFAULT_CONFIG = {
    "csv": {
        "chunksize": 100_000,
        "encoding": "utf-8",
        "date_formats": [
            "%Y-%m-%d", "%d/%m/%Y", "%m/%d/%Y", "%Y/%m/%d",
            "%d-%m-%Y", "%Y.%m.%d", "%d.%m.%Y"
        ],
        "parse_dates_column": "date",
        "columns": {"date": "date", "product_id": "product_id", "quantity": "quantity", "price": "price"},
    },
    "cleaning": {
        "strict_mode": False,
        "drop_bad_rows": True,
        "currency_symbols": ["$", "€", "£", "¥", "USD", "EUR", "SAR", "EGP"],
        "invalid_unicode_action": "replace",
    },
    "output": {
        "summary_filename": "summary.json",
        "aggregate_filename": "aggregate.csv",
        "plot_filename": "top_products.png"
    },
    "logging": {"level": "INFO"},
}

# === فئة التكوين ===
@dataclass
class Config:
    chunksize: int = 100_000
    encoding: str = "utf-8"
    date_formats: List[str] = field(default_factory=lambda: DEFAULT_CONFIG["csv"]["date_formats"])
    parse_dates_column: str = "date"
    columns: Dict[str, str] = field(default_factory=lambda: DEFAULT_CONFIG["csv"]["columns"])
    strict_mode: bool = False
    drop_bad_rows: bool = True
    currency_symbols: List[str] = field(default_factory=lambda: DEFAULT_CONFIG["cleaning"]["currency_symbols"])
    invalid_unicode_action: str = "replace"
    summary_filename: str = "summary.json"
    aggregate_filename: str = "aggregate.csv"
    plot_filename: str = "top_products.png"
    log_level: str = "INFO"

    @staticmethod
    def from_dict(d: Dict) -> "Config":
        csv_cfg = d.get("csv", {})
        cleaning = d.get("cleaning", {})
        output = d.get("output", {})
        logging_cfg = d.get("logging", {})
        return Config(
            chunksize=int(csv_cfg.get("chunksize", DEFAULT_CONFIG["csv"]["chunksize"])),
            encoding=str(csv_cfg.get("encoding", DEFAULT_CONFIG["csv"]["encoding"])),
            date_formats=csv_cfg.get("date_formats", DEFAULT_CONFIG["csv"]["date_formats"]),
            parse_dates_column=str(csv_cfg.get("parse_dates_column", DEFAULT_CONFIG["csv"]["parse_dates_column"])),
            columns=csv_cfg.get("columns", DEFAULT_CONFIG["csv"]["columns"]),
            strict_mode=bool(cleaning.get("strict_mode", DEFAULT_CONFIG["cleaning"]["strict_mode"])),
            drop_bad_rows=bool(cleaning.get("drop_bad_rows", DEFAULT_CONFIG["cleaning"]["drop_bad_rows"])),
            currency_symbols=cleaning.get("currency_symbols", DEFAULT_CONFIG["cleaning"]["currency_symbols"]),
            invalid_unicode_action=cleaning.get("invalid_unicode_action", DEFAULT_CONFIG["cleaning"]["invalid_unicode_action"]),
            summary_filename=output.get("summary_filename", DEFAULT_CONFIG["output"]["summary_filename"]),
            aggregate_filename=output.get("aggregate_filename", DEFAULT_CONFIG["output"]["aggregate_filename"]),
            plot_filename=output.get("plot_filename", DEFAULT_CONFIG["output"]["plot_filename"]),
            log_level=logging_cfg.get("level", DEFAULT_CONFIG["logging"]["level"]),
        )

def load_config_file(path: Optional[Path]) -> Config:
    if not path or not path.exists():
        return Config.from_dict(DEFAULT_CONFIG)
    try:
        with open(path, "r", encoding="utf-8") as fh:
            raw = yaml.safe_load(fh) or {}
        return Config.from_dict(raw)
    except Exception as e:
        logging.warning(f"فشل تحميل ملف التكوين {path}: {e}")
        return Config.from_dict(DEFAULT_CONFIG)

def setup_logging(level: str = "INFO") -> None:
    numeric = getattr(logging, level.upper(), logging.INFO)
    logging.basicConfig(
        level=numeric,
        format="%(asctime)s | %(levelname)-8s | %(message)s",
        datefmt="%H:%M:%S"
    )

# === تنظيف وتحليل البيانات ===
def try_rename_similar_columns(df_columns: List[str], expected: Dict[str, str]) -> Dict[str, str]:
    mapping: Dict[str, str] = {}
    normalized = {re.sub(r"\W+", "", c).lower(): c for c in df_columns}

    for exp_key, exp_name in expected.items():
        candidates = [
            c for c in df_columns
            if c.lower() == exp_name.lower() or
               re.sub(r"\W+", "", c).lower() == re.sub(r"\W+", "", exp_name).lower() or
               c.lower().startswith(exp_name[:3].lower())
        ]
        if candidates:
            mapping[exp_key] = candidates[0]
    return mapping

def clean_currency_value(value: Any, symbols: List[str]) -> Optional[float]:
    if pd.isna(value): return None
    s = str(value)
    for sym in symbols:
        s = s.replace(sym, "")
    s = re.sub(r"[^\d\.\-]", "", s.replace(",", ""))
    return float(s) if s else None

def parse_int_like(value: Any) -> Optional[int]:
    if pd.isna(value): return None
    s = re.sub(r"[^\d\-]", "", str(value))
    return int(s) if s and s != "-" else None

def parse_date_with_formats(value: Any, formats: List[str]) -> Optional[pd.Timestamp]:
    if pd.isna(value): return None
    s = str(value).strip()
    for fmt in formats:
        try:
            return pd.Timestamp(datetime.strptime(s, fmt).date())
        except: continue
    dt = pd.to_datetime(s, errors="coerce")
    return pd.Timestamp(dt.date()) if pd.notna(dt) else None

# === المجمع ===
@dataclass
class Aggregator:
    total_sales: float = 0.0
    total_quantity: int = 0
    product_totals: Dict[str, float] = field(default_factory=lambda: defaultdict(float))
    product_quantities: Dict[str, int] = field(default_factory=lambda: defaultdict(int))
    rows_processed: int = 0
    rows_skipped: int = 0
    bad_rows: List[Dict] = field(default_factory=list)

    def ingest_row(self, product_id: str, quantity: int, price: float) -> None:
        self.rows_processed += 1
        qty, price = int(quantity), float(price)
        revenue = qty * price
        self.total_sales += revenue
        self.total_quantity += qty
        self.product_totals[product_id] += revenue
        self.product_quantities[product_id] += qty

    def record_bad_row(self, row: Dict, reason: str) -> None:
        self.rows_skipped += 1
        sample = dict(row)
        sample["_error"] = reason
        if len(self.bad_rows) < 100:
            self.bad_rows.append(sample)

    def to_summary(self) -> Dict:
        top = sorted(self.product_totals.items(), key=lambda x: x[1], reverse=True)[:20]
        return {
            "generated_at": datetime.utcnow().isoformat() + "Z",
            "rows_processed": self.rows_processed,
            "rows_skipped": self.rows_skipped,
            "total_sales": round(self.total_sales, 2),
            "total_quantity": self.total_quantity,
            "unique_products": len(self.product_totals),
            "top_products": [
                {"product_id": p, "revenue": round(r, 2), "quantity": self.product_quantities[p]}
                for p, r in top
            ],
            "bad_rows_sample": self.bad_rows[:20]
        }

    def to_aggregate_dataframe(self) -> pd.DataFrame:
        df = pd.DataFrame([
            {"product_id": p, "total_revenue": round(r, 2), "total_quantity": q}
            for p, (r, q) in [(p, (r, self.product_quantities[p])) for p, r in self.product_totals.items()]
        ])
        return df.sort_values("total_revenue", ascending=False) if not df.empty else df

# === معالجة الملف ===
def process_csv(input_path: Path, cfg: Config, aggregator: Aggregator, sample_mode: bool = False) -> None:
    read_kwargs = {
        "chunksize": cfg.chunksize,
        "encoding": cfg.encoding,
        "dtype": str,
        "keep_default_na": False,
        "na_values": ["", "NA", "N/A", "null", "None", "NULL"]
    }

    with open(input_path, "r", encoding=cfg.encoding, errors="replace") as f:
        header = f.readline().strip().split(",")
    mapping = try_rename_similar_columns(header, cfg.columns)

    if cfg.strict_mode and not all(k in mapping for k in cfg.columns):
        raise ValueError(f"أعمدة مفقودة: {[k for k in cfg.columns if k not in mapping]}")

    for chunk_idx, chunk in enumerate(pd.read_csv(input_path, **read_kwargs)):
        logging.info(f"معالجة الكتلة {chunk_idx + 1} ({len(chunk):,} صف)")
        col_map = try_rename_similar_columns(list(chunk.columns), cfg.columns)
        chunk = chunk.rename(columns={v: k for k, v in col_map.items() if v != k})

        for _, row in chunk.iterrows():
            if sample_mode and aggregator.rows_processed >= 1000:
                logging.info("وضع العينة: تم إيقاف المعالجة عند 1000 صف")
                return

            try:
                prod = str(row.get("product_id", "")).strip()
                if not prod:
                    aggregator.record_bad_row(row.to_dict(), "missing_product_id")
                    continue

                qty = parse_int_like(row.get("quantity"))
                if qty is None:
                    aggregator.record_bad_row(row.to_dict(), "invalid_quantity")
                    continue

                price = clean_currency_value(row.get("price"), cfg.currency_symbols)
                if price is None or price <= 0:
                    aggregator.record_bad_row(row.to_dict(), "invalid_price")
                    continue

                aggregator.ingest_row(prod, qty, price)
            except Exception as e:
                aggregator.record_bad_row(row.to_dict(), f"exception: {e}")
                continue

# === الكتابة والرسم ===
def write_summary_json(data: Dict, path: Path):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

def write_aggregate_csv(df: pd.DataFrame, path: Path):
    path.parent.mkdir(parents=True, exist_ok=True)
    df.to_csv(path, index=False, encoding="utf-8")

def plot_top_products(agg: Aggregator, path: Path, top_n: int = 15):
    df = agg.to_aggregate_dataframe().head(top_n)
    if df.empty:
        logging.warning("لا توجد بيانات للرسم البياني")
        return
    plt.figure(figsize=(12, 8))
    plt.barh(df["product_id"].astype(str)[::-1], df["total_revenue"][::-1], color="#4CAF50")
    plt.xlabel("إجمالي المبيعات")
    plt.title(f"أعلى {len(df)} منتجات من حيث الإيرادات")
    plt.tight_layout()
    path.parent.mkdir(parents=True, exist_ok=True)
    plt.savefig(path, dpi=150, bbox_inches="tight")
    plt.close()
    logging.info(f"تم حفظ الرسم البياني: {path}")

# === واجهة المستخدم (PyQt6) ===
if PYQT_AVAILABLE:
    class GUIWorker(QtCore.QObject):
        log = pyqtSignal(str)
        finished = pyqtSignal(int)
        plot_ready = pyqtSignal(str)

        def run_processing(self, input_csv: str, output_dir: str, config_path: Optional[str], sample: bool, log_level: str):
            try:
                setup_logging(log_level)
                cfg = load_config_file(Path(config_path) if config_path else None)
                agg = Aggregator()

                self.log.emit(f"بدء معالجة الملف: {input_csv}")
                process_csv(Path(input_csv), cfg, agg, sample_mode=sample)

                out_dir = Path(output_dir)
                write_summary_json(agg.to_summary(), out_dir / cfg.summary_filename)
                write_aggregate_csv(agg.to_aggregate_dataframe(), out_dir / cfg.aggregate_filename)
                plot_path = out_dir / cfg.plot_filename
                plot_top_products(agg, plot_path)
                self.plot_ready.emit(str(plot_path))

                self.log.emit("اكتملت المعالجة بنجاح!")
                self.finished.emit(0)
            except Exception as e:
                logging.exception("خطأ في المعالجة")
                self.log.emit(f"خطأ: {e}")
                self.finished.emit(1)

    class MainWindow(QtWidgets.QMainWindow):
        def __init__(self):
            super().__init__()
            self.setWindowTitle("معالج مبيعات - واجهة رسومية مدمجة")
            self.resize(1000, 720)
            self.worker = GUIWorker()
            self.thread = QThread()
            self.worker.moveToThread(self.thread)
            self.thread.started.connect(lambda: self.worker.run_processing(
                self.input_edit.text(),
                self.output_edit.text(),
                self.config_edit.text().strip() or None,
                self.sample_cb.isChecked(),
                self.log_combo.currentText()
            ))
            self.worker.log.connect(self.append_log)
            self.worker.finished.connect(self.on_finished)
            self.worker.plot_ready.connect(self.show_plot)

            # الواجهة
            central = QtWidgets.QWidget()
            self.setCentralWidget(central)
            layout = QtWidgets.QVBoxLayout(central)

            # النموذج
            form = QtWidgets.QFormLayout()
            self.input_edit = QtWidgets.QLineEdit()
            btn = QtWidgets.QPushButton("استعراض...")
            btn.clicked.connect(self.browse_input)
            h = QtWidgets.QHBoxLayout(); h.addWidget(self.input_edit, 1); h.addWidget(btn)
            form.addRow("ملف الإدخال (CSV):", h)

            self.output_edit = QtWidgets.QLineEdit("out")
            btn2 = QtWidgets.QPushButton("استعراض...")
            btn2.clicked.connect(self.browse_output)
            h2 = QtWidgets.QHBoxLayout(); h2.addWidget(self.output_edit, 1); h2.addWidget(btn2)
            form.addRow("مجلد الإخراج:", h2)

            self.config_edit = QtWidgets.QLineEdit()
            btn3 = QtWidgets.QPushButton("اختياري")
            btn3.clicked.connect(self.browse_config)
            h3 = QtWidgets.QHBoxLayout(); h3.addWidget(self.config_edit, 1); h3.addWidget(btn3)
            form.addRow("ملف التكوين (YAML):", h3)

            opts = QtWidgets.QHBoxLayout()
            self.sample_cb = QtWidgets.QCheckBox("وضع العينة (1000 صف فقط)")
            self.log_combo = QtWidgets.QComboBox()
            self.log_combo.addItems(["DEBUG", "INFO", "WARNING", "ERROR"])
            self.log_combo.setCurrentText("INFO")
            opts.addWidget(self.sample_cb)
            opts.addStretch()
            opts.addWidget(QtWidgets.QLabel("مستوى السجل:"))
            opts.addWidget(self.log_combo)
            form.addRow(opts)

            layout.addLayout(form)

            # أزرار
            btns = QtWidgets.QHBoxLayout()
            self.start_btn = QtWidgets.QPushButton("بدء المعالجة")
            self.start_btn.clicked.connect(self.start_processing)
            btns.addWidget(self.start_btn)
            btns.addStretch()
            layout.addLayout(btns)

            # السجل
            self.log_view = QtWidgets.QPlainTextEdit()
            self.log_view.setReadOnly(True)
            self.log_view.setFont(QtGui.QFont("Courier", 10))
            layout.addWidget(QtWidgets.QLabel("سجل الأحداث:"))
            layout.addWidget(self.log_view, 2)

            # الرسم البياني
            self.image_label = QtWidgets.QLabel("سيظهر الرسم البياني هنا بعد المعالجة...")
            self.image_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.image_label.setMinimumHeight(300)
            self.image_label.setStyleSheet("background: #f0f0f0; border: 1px solid #ccc;")
            self.image_label.setScaledContents(True)  # الحل السحري!
            layout.addWidget(self.image_label, 2)

        def browse_input(self):
            path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "اختر ملف CSV", "", "CSV Files (*.csv);;All Files (*)")
            if path: self.input_edit.setText(path)

        def browse_output(self):
            path = QtWidgets.QFileDialog.getExistingDirectory(self, "اختر مجلد الإخراج")
            if path: self.output_edit.setText(path)

        def browse_config(self):
            path, _ = QtWidgets.QFileDialog.getOpenFileName(self, "اختر ملف YAML", "", "YAML (*.yml *.yaml)")
            if path: self.config_edit.setText(path)

        def start_processing(self):
            inp = self.input_edit.text().strip()
            out = self.output_edit.text().strip()
            if not inp or not Path(inp).exists():
                QtWidgets.QMessageBox.critical(self, "خطأ", "يرجى اختيار ملف CSV صحيح")
                return
            if not out:
                QtWidgets.QMessageBox.critical(self, "خطأ", "يرجى اختيار مجلد إخراج")
                return

            self.start_btn.setEnabled(False)
            self.log_view.clear()
            self.image_label.setPixmap(QtGui.QPixmap())
            self.append_log("جاري بدء المعالجة...")
            self.thread.start()

        def append_log(self, text: str):
            self.log_view.appendPlainText(text)

        def show_plot(self, path: str):
            pix = QtGui.QPixmap(path)
            if not pix.isNull():
                self.image_label.setPixmap(pix)

        def on_finished(self, code: int):
            self.append_log("=== انتهت المعالجة ===" if code == 0 else "=== فشلت المعالجة ===")
            self.start_btn.setEnabled(True)
            self.thread.quit()
            self.thread.wait()

# === تشغيل الواجهة ===
def start_gui():
    if not PYQT_AVAILABLE:
        print("PyQt6 غير مثبت. استخدم: pip install PyQt6")
        return
    app = QtWidgets.QApplication(sys.argv)
    app.setStyle("Fusion")
    win = MainWindow()
    win.show()
    sys.exit(app.exec())

# === CLI ===
def cli_main():
    parser = argparse.ArgumentParser(description="معالج مبيعات - CLI + GUI")
    parser.add_argument("--input", help="ملف CSV الإدخال")
    parser.add_argument("--output-dir", default="out", help="مجلد الإخراج")
    parser.add_argument("--config", help="ملف التكوين YAML")
    parser.add_argument("--sample", action="store_true", help="وضع العينة")
    parser.add_argument("--gui", action="store_true", help="تشغيل الواجهة الرسومية")
    parser.add_argument("--log-level", default="INFO")
    args = parser.parse_args()

    if args.gui:
        start_gui()
        return

    if not args.input:
        parser.print_help()
        return

    input_path = Path(args.input)
    if not input_path.exists():
        print("الملف غير موجود:", input_path)
        return

    cfg = load_config_file(Path(args.config) if args.config else None)
    cfg.log_level = args.log_level
    setup_logging(cfg.log_level)

    agg = Aggregator()
    process_csv(input_path, cfg, agg, sample_mode=args.sample)

    out = Path(args.output_dir)
    out.mkdir(exist_ok=True, parents=True)
    write_summary_json(agg.to_summary(), out / cfg.summary_filename)
    write_aggregate_csv(agg.to_aggregate_dataframe(), out / cfg.aggregate_filename)
    plot_top_products(agg, out / cfg.plot_filename)

    print(f"تم الإنجاز! المخرجات في: {out.resolve()}")

if __name__ == "__main__":
    cli_main()
