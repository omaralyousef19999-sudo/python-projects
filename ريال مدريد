# uefa_app.py
from kivy.app import App
from kivy.lang import Builder
from kivy.properties import StringProperty, BooleanProperty, ObjectProperty, NumericProperty
from kivy.uix.screenmanager import Screen
from kivy.clock import Clock
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.gridlayout import GridLayout
from kivy.uix.popup import Popup
from kivy.uix.label import Label
from kivy.uix.button import Button
from kivy.uix.scrollview import ScrollView
from kivy.graphics import Color, Rectangle, Ellipse
from kivy.uix.widget import Widget
from kivy.uix.textinput import TextInput
import random
import datetime
import math

# Teams data
TEAMS_BY_COUNTRY = {
    "Spain": ["Real Madrid", "Barcelona", "Atletico Madrid", "Sevilla"],
    "France": ["PSG", "Marseille", "Lyon", "Monaco"],
    "Germany": ["Bayern Munich", "Borussia Dortmund", "RB Leipzig", "Bayer Leverkusen"],
    "England": ["Manchester City", "Manchester United", "Chelsea", "Liverpool"],
    "Italy": ["Juventus", "Inter", "AC Milan", "Napoli"],
}

ALL_TEAMS = []
for country, teams in TEAMS_BY_COUNTRY.items():
    for team in teams:
        ALL_TEAMS.append({"name": team, "country": country})

# Tournament state
class TournamentState:
    def __init__(self):
        self.drawn_matches = []
        self.next_match_id = 1
        self.round = 1
        self.remaining_teams = ALL_TEAMS.copy()
        self.winner = None

    def add_match(self, home, away):
        m = {
            "id": self.next_match_id,
            "home": home,
            "away": away, 
            "datetime": datetime.datetime.now(),
            "score": None
        }
        self.next_match_id += 1
        self.drawn_matches.append(m)
        return m

    def save_score(self, match_id, home_goals, away_goals):
        for m in self.drawn_matches:
            if m["id"] == match_id:
                m["score"] = (int(home_goals), int(away_goals))
                return m
        return None

    def qualify_next_round(self):
        winners = []
        for m in self.drawn_matches:
            if m["score"] is None:
                continue
            hg, ag = m["score"]
            if hg > ag:
                winners.append(m["home"])
            elif hg < ag:
                winners.append(m["away"])
            else:
                winners.append(random.choice([m["home"], m["away"]]))
        
        self.round += 1
        self.remaining_teams = winners
        self.drawn_matches = []
        
        if len(self.remaining_teams) == 1:
            self.winner = self.remaining_teams[0]
        return self.remaining_teams

STATE = TournamentState()

# UI
KV = '''
<DrawScreen>:
    BoxLayout:
        orientation: 'vertical'
        padding: 20
        spacing: 10
        
        Label:
            text: 'Champions League - Draw System'
            font_size: 24
            size_hint_y: None
            height: 50
        
        BoxLayout:
            size_hint_y: None
            height: 50
            spacing: 10
            Button:
                text: 'Matches'
                on_release: app.root.current = 'matches'
            Button:
                text: 'Standings' 
                on_release: app.root.current = 'standings'
            Button:
                text: 'Reset'
                on_release: root.reset_tournament()
        
        Label:
            text: 'Round: ' + str(root.round_label)
            size_hint_y: None
            height: 30
        
        BoxLayout:
            spacing: 20
            BoxLayout:
                orientation: 'vertical'
                size_hint_x: 0.4
                Label:
                    text: root.left_name
                    font_size: 20
                    text_size: self.width, None
                    halign: 'center'
                Label:
                    text: root.left_country
                    font_size: 14
                    color: 0.7, 0.7, 0.7, 1
            
            BoxLayout:
                orientation: 'vertical'
                size_hint_x: 0.2
                spacing: 10
                Button:
                    text: 'Random Draw'
                    on_release: root.spin_once()
                Button:
                    text: 'Save Match'
                    on_release: root.save_match()
            
            BoxLayout:
                orientation: 'vertical'
                size_hint_x: 0.4
                Label:
                    text: root.right_name
                    font_size: 20
                    text_size: self.width, None
                    halign: 'center'
                Label:
                    text: root.right_country
                    font_size: 14
                    color: 0.7, 0.7, 0.7, 1
        
        ScrollView:
            Label:
                id: log_label
                text_size: self.width, None
                size_hint_y: None
                height: self.texture_size[1]
                text: root.log_text

<MatchesScreen>:
    BoxLayout:
        orientation: 'vertical'
        padding: 20
        spacing: 10
        
        BoxLayout:
            size_hint_y: None
            height: 50
            Button:
                text: 'Draw'
                on_release: app.root.current = 'draw'
            Button:
                text: 'Standings'
                on_release: app.root.current = 'standings'
            Button:
                text: 'Next Round'
                on_release: root.qualify_next_round()
        
        ScrollView:
            GridLayout:
                id: matches_grid
                cols: 1
                size_hint_y: None
                height: self.minimum_height
                spacing: 5

<StandingsScreen>:
    BoxLayout:
        orientation: 'vertical'
        padding: 20
        spacing: 10
        
        BoxLayout:
            size_hint_y: None
            height: 50
            Button:
                text: 'Draw'
                on_release: app.root.current = 'draw'
            Button:
                text: 'Matches'
                on_release: app.root.current = 'matches'
            Label:
                text: 'Round: ' + str(root.round_label)
        
        ScrollView:
            GridLayout:
                id: standings_grid
                cols: 1
                size_hint_y: None
                height: self.minimum_height

ScreenManager:
    id: screen_manager
    DrawScreen:
        name: 'draw'
    MatchesScreen:
        name: 'matches'
    StandingsScreen:
        name: 'standings'
'''

class DrawScreen(Screen):
    left_name = StringProperty("---")
    left_country = StringProperty("")
    right_name = StringProperty("---")
    right_country = StringProperty("")
    round_label = NumericProperty(1)
    log_text = StringProperty("")

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.round_label = STATE.round
        self.update_log()

    def spin_once(self):
        if len(STATE.remaining_teams) < 2:
            self.log_text += "\\nNot enough teams for draw!"
            return

        left = random.choice(STATE.remaining_teams)
        right = random.choice(STATE.remaining_teams)
        
        # Make sure teams are different
        attempts = 0
        while left["name"] == right["name"] and attempts < 10:
            right = random.choice(STATE.remaining_teams)
            attempts += 1

        self.left_name = left["name"]
        self.left_country = left["country"]
        self.right_name = right["name"]
        self.right_country = right["country"]

    def save_match(self):
        if self.left_name == "---" or self.right_name == "---":
            self.log_text += "\\nPlease draw first!"
            return

        home_team = {"name": self.left_name, "country": self.left_country}
        away_team = {"name": self.right_name, "country": self.right_country}
        
        match = STATE.add_match(home_team, away_team)
        self.log_text += f"\\nAdded: {home_team['name']} vs {away_team['name']}"
        
        # Reset display
        self.left_name = "---"
        self.left_country = ""
        self.right_name = "---" 
        self.right_country = ""

    def update_log(self):
        self.log_text = "Match Log:\\n"
        for match in STATE.drawn_matches[-10:]:
            self.log_text += f"{match['home']['name']} vs {match['away']['name']}\\n"

    def reset_tournament(self):
        global STATE
        STATE = TournamentState()
        self.round_label = STATE.round
        self.left_name = "---"
        self.right_name = "---"
        self.update_log()
        App.get_running_app().update_all_screens()

class MatchesScreen(Screen):
    def on_enter(self):
        self.update_matches()

    def update_matches(self):
        grid = self.ids.matches_grid
        grid.clear_widgets()

        for match in STATE.drawn_matches:
            # Match row
            row = BoxLayout(size_hint_y=None, height=40)
            
            # Teams display
            teams_label = Label(
                text=f"{match['home']['name']} vs {match['away']['name']}",
                size_hint_x=0.6
            )
            
            # Score display or input button
            if match["score"]:
                score_label = Label(
                    text=f"{match['score'][0]} - {match['score'][1]}",
                    size_hint_x=0.3
                )
                row.add_widget(score_label)
            else:
                score_btn = Button(
                    text="Enter Score",
                    size_hint_x=0.3,
                    on_release=lambda btn, m=match: App.get_running_app().open_score_popup(m["id"])
                )
                row.add_widget(score_btn)
            
            row.add_widget(teams_label)
            grid.add_widget(row)

    def qualify_next_round(self):
        # Check if all matches have scores
        incomplete = [m for m in STATE.drawn_matches if m["score"] is None]
        if incomplete:
            Popup(
                title='Warning',
                content=Label(text='Some matches dont have scores!'),
                size_hint=(0.6, 0.3)
            ).open()
            return
        
        STATE.qualify_next_round()
        App.get_running_app().update_all_screens()

class StandingsScreen(Screen):
    round_label = NumericProperty(1)

    def on_enter(self):
        self.update_standings()

    def update_standings(self):
        self.round_label = STATE.round
        grid = self.ids.standings_grid
        grid.clear_widgets()

        # Table header
        header = BoxLayout(size_hint_y=None, height=30)
        header.add_widget(Label(text="Team", size_hint_x=0.4))
        header.add_widget(Label(text="P", size_hint_x=0.15))
        header.add_widget(Label(text="W", size_hint_x=0.15))
        header.add_widget(Label(text="D", size_hint_x=0.15))
        header.add_widget(Label(text="L", size_hint_x=0.15))
        grid.add_widget(header)

        # Team data
        for team in STATE.remaining_teams:
            row = BoxLayout(size_hint_y=None, height=25)
            row.add_widget(Label(text=team["name"], size_hint_x=0.4))
            # Default stats (can be improved later)
            row.add_widget(Label(text="0", size_hint_x=0.15))
            row.add_widget(Label(text="0", size_hint_x=0.15))
            row.add_widget(Label(text="0", size_hint_x=0.15))
            row.add_widget(Label(text="0", size_hint_x=0.15))
            grid.add_widget(row)

class ChampionsLeagueApp(App):
    def build(self):
        self.title = "Champions League"
        return Builder.load_string(KV)

    def on_start(self):
        self.update_all_screens()

    def update_all_screens(self):
        # Update all screens
        draw_screen = self.root.get_screen('draw')
        draw_screen.round_label = STATE.round
        draw_screen.update_log()

        matches_screen = self.root.get_screen('matches')
        matches_screen.update_matches()

        standings_screen = self.root.get_screen('standings')
        standings_screen.update_standings()

    def open_score_popup(self, match_id):
        match = next((m for m in STATE.drawn_matches if m["id"] == match_id), None)
        if not match:
            return

        content = BoxLayout(orientation='vertical', spacing=10, padding=10)
        
        # Match title
        title = Label(text=f"{match['home']['name']} vs {match['away']['name']}")
        content.add_widget(title)

        # Score input
        score_layout = BoxLayout(size_hint_y=None, height=50)
        home_input = TextInput(
            text=str(match["score"][0]) if match["score"] else "0",
            input_filter='int',
            size_hint_x=0.3
        )
        away_input = TextInput(
            text=str(match["score"][1]) if match["score"] else "0", 
            input_filter='int',
            size_hint_x=0.3
        )
        
        score_layout.add_widget(Label(text="Goals", size_hint_x=0.2))
        score_layout.add_widget(home_input)
        score_layout.add_widget(Label(text="-", size_hint_x=0.1))
        score_layout.add_widget(away_input)
        score_layout.add_widget(Label(text="Goals", size_hint_x=0.2))
        content.add_widget(score_layout)

        # Save/Cancel buttons
        btn_layout = BoxLayout(size_hint_y=None, height=50)
        save_btn = Button(text="Save")
        cancel_btn = Button(text="Cancel")
        btn_layout.add_widget(save_btn)
        btn_layout.add_widget(cancel_btn)
        content.add_widget(btn_layout)

        popup = Popup(
            title='Enter Score',
            content=content,
            size_hint=(0.8, 0.4)
        )

        def save_score(instance):
            try:
                home_goals = int(home_input.text)
                away_goals = int(away_input.text)
                STATE.save_score(match_id, home_goals, away_goals)
                self.update_all_screens()
                popup.dismiss()
            except ValueError:
                pass

        save_btn.bind(on_release=save_score)
        cancel_btn.bind(on_release=popup.dismiss)
        
        popup.open()

if __name__ == '__main__':
    ChampionsLeagueApp().run()
